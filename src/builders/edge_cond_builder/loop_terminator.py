"""
Ensures CFG loops terminate by adding operations to loop latch nodes

Modifies the CFG in-place based on pre-computed loop analysis results.
Uses `OperationsBuilder` to generate operations that modify loop control
variables, guaranteeing the loop condition eventually becomes false

Process:
1. Takes CFG and `LoopAnalysisInfo` (containing headers, bodies, latches)
2. For each loop:
   - Finds the continuation condition (`Expression`)
   - Selects a variable from the condition (preferring integers)
   - Uses `OperationsBuilder` to create a terminating `Operation` for that variable
   - Adds the operation to the `operations` list of the loop's latch node(s)
   - Updates `LoopAnalysisInfo` to mark the modified variable as critical

Note:
- Relies on accurate `LoopAnalysisInfo` from `cfg_analysis`
- Relies on `EdgeCondBuilder` having set feasible edge conditions
- Only adds `Operation`s, does not modify edge `Expression`s
- Success depends on `OperationsBuilder` creating effective termination ops

Depends on: `CFG`, `LoopAnalysisInfo`, `OperationsBuilder`, `AppConfig`
"""

from typing import Optional, Set, cast, List, Tuple
from dataclasses import dataclass, field
from loguru import logger

from src.core.cfg.cfg import CFG
from src.core.nodes.cfg_basic_block_node import CFGBasicBlockNode
from src.core.cfg_content.expression import Expression, ArithmeticExpression, Constant, VariableExpression
from src.core.cfg_content.variable import Variable, VariableType
from src.core.cfg_content.operation import Operation, ArithmeticOperation
from src.core.cfg_content.operator import ArithmeticOperator
from src.builders.oper_builder.operations_random_factory import OperationsBuilder
from src.config.config import AppConfig
from src.utils.logging_helpers import print_loop_termination_summary

__author__ = "Vladimir Azarov"
__email__ = "azarov.swe@gmail.com"
__version__ = "1.0.0"
__license__ = "MIT"

@dataclass
class LoopTerminator:
    """Ensures identified loops in a CFG terminate by adding operations

    Uses pre-computed loop analysis data to find loop latches and conditions
    Adds operations (generated by `OperationsBuilder`) to latch nodes to modify
    loop control variables, guaranteeing eventual termination. Updates the
    analysis data with variables critical for termination

    Attributes:
        cfg: The control flow graph being modified
        app_config: Application configuration
        operation_factory: Factory to create termination operations
    """
    cfg: CFG
    app_config: AppConfig
    operation_factory: OperationsBuilder = field(init=False)

    def __post_init__(self):
        """Initialize the operation factory"""
        self.operation_factory = OperationsBuilder(self.app_config)

    def ensure_all_loops_terminate(self) -> None:
        """Adds terminating operations to loops identified by CFGAnalysis

        Retrieves pre-computed loop information from self.cfg.analysis
        Iterates through loop headers, finds latch nodes, gets the condition,
        selects a variable, generates a terminating operation, adds it to latches,
        and updates the analysis info with critical variables

        Requires self.cfg.run_analysis() to have been called previously
        """
        cfg = self.cfg
        logger.info("Starting loop termination process using analysis results from cfg.analysis...")

        if cfg.analysis is None:
            logger.error("CFG analysis results not found (cfg.analysis is None). Run cfg.run_analysis() first. Skipping termination.")
            return

        loop_analysis_info = cfg.analysis.get_loop_info()

        if not loop_analysis_info:
            logger.warning("LoopAnalysisInfo from cfg.analysis is empty. No loops to process.")
            return

        processed_latch_nodes: Set[CFGBasicBlockNode] = set()
        processed_loops_count = 0
        added_assignments: List[Tuple[int, str]] = []

        for loop_header, info_dict in loop_analysis_info.items():
            processed_loops_count += 1
            logger.debug(f"Processing loop header {loop_header.node_id} from analysis info.")

            raw_latch_nodes = info_dict.get('latch_nodes')
            if not isinstance(raw_latch_nodes, set):
                 logger.warning(f"  Loop {loop_header.node_id}: 'latch_nodes' in analysis info is not a set (type: {type(raw_latch_nodes)}). Skipping.")
                 continue
            latch_nodes: Set[CFGBasicBlockNode] = cast(Set[CFGBasicBlockNode], raw_latch_nodes)
            if not latch_nodes:
                logger.warning(f"  Loop {loop_header.node_id}: No latch nodes found in analysis info. Skipping.")
                continue

            logger.debug(f"  Latch nodes for header {loop_header.node_id}: {[l.node_id for l in latch_nodes]}")

            continuation_condition = self._get_loop_continuation_condition(loop_header)
            if continuation_condition is None:
                 logger.warning(f"Loop {loop_header.node_id}: Could not determine continuation condition via _get_loop_continuation_condition. Skipping.")
                 continue

            loop_variables = continuation_condition.get_variables()
            if not loop_variables:
                 logger.warning(f"Loop {loop_header.node_id}: Condition '{continuation_condition.to_c()}' has no variables. Cannot guarantee termination.")
                 continue
            logger.debug(f"Loop {loop_header.node_id}: Variables in condition: {[v.name for v in loop_variables]}")

            target_variable = self._select_termination_variable(loop_variables)
            if target_variable is None:
                 logger.error(f"Loop {loop_header.node_id}: Could not select a target variable from {loop_variables}. Skipping.")
                 continue

            for latch_node in latch_nodes:
                if latch_node in processed_latch_nodes:
                    logger.trace(f"Latch node {latch_node.node_id} already processed (likely shared by nested loops). Skipping duplicate termination op.")
                    continue

                logger.debug(f"Loop {loop_header.node_id}: Adding termination op targeting '{target_variable.name}' to latch node {latch_node.node_id}")
                terminating_op = self.operation_factory.create_loop_breaking_operation(
                    target_variable=target_variable,
                    loop_condition=continuation_condition
                )

                if terminating_op:
                    self._add_operation_to_node(latch_node, terminating_op)
                    added_assignments.append((latch_node.node_id, terminating_op.to_c()))

                    crit_vars_set = info_dict.setdefault('critical_termination_vars', set())
                    if isinstance(crit_vars_set, set):
                        cast(Set[Variable], crit_vars_set).add(target_variable)
                        logger.trace(f"  Marked '{target_variable.name}' as critical for loop {loop_header.node_id}")
                    else:
                        logger.warning(f"  Loop {loop_header.node_id}: 'critical_termination_vars' in analysis info was not a set (type: {type(crit_vars_set)}). Cannot mark variable.")

                    processed_latch_nodes.add(latch_node)
                else:
                     logger.warning(f"Loop {loop_header.node_id}: Operation factory failed to create termination op for var '{target_variable.name}' on node {latch_node.node_id}.")

        logger.info(f"Loop termination process completed processing {processed_loops_count} loops from cfg.analysis.")
        print_loop_termination_summary(added_assignments)

    def _get_loop_continuation_condition(self, header: CFGBasicBlockNode) -> Optional[Expression]:
        """Helper to find the loop continuation condition directly from the header jump node

        Args:
            header (CFGBasicBlockNode): The header node of the loop

        Returns:
            Optional[Expression]: The continuation condition expression, or None
        """
        # Ensure jump and expression exist and expression is the correct type
        if header.jump and hasattr(header.jump, 'expression'):
            jump_expr = header.jump.expression
            if isinstance(jump_expr, Expression):
                logger.trace(f"Loop {header.node_id}: Found condition in jump node: {jump_expr.to_c()}")
                return jump_expr
            elif jump_expr is not None:
                 logger.warning(f"Loop {header.node_id}: Jump node expression is not an Expression instance (Type: {type(jump_expr)}).")

        logger.warning(f"Loop {header.node_id}: Could not find continuation condition in jump node.")
        return None

    def _select_termination_variable(self, loop_variables: Set[Variable]) -> Optional[Variable]:
        """Helper to select a variable to modify for loop termination

        Prioritizes selecting an integer variable if available
        Otherwise, returns the first variable in the set

        Args:
            loop_variables (Set[Variable]): Variables found in the loop condition

        Returns:
            Optional[Variable]: The selected variable, or None if the input set is empty
        """
        if not loop_variables:
             return None

        # Prioritize integer variables
        for var in loop_variables:
             if var.type == VariableType.INT:
                  return var

        return next(iter(loop_variables))

    def _add_operation_to_node(self, node: CFGBasicBlockNode, op: Operation) -> None:
        """Helper to add an operation to a node's instruction list

        Args:
            node (CFGBasicBlockNode): The node to add the operation to
            op (Operation): The operation to add
        """
        # Ensure instructions node exists
        if node.instructions is None:
            logger.error(f"Cannot add operation to node {node.node_id}: instructions attribute is None.")
            return
        # Ensure operations list exists
        if not hasattr(node.instructions, 'operations') or not isinstance(node.instructions.operations, list):
             logger.error(f"Cannot add operation to node {node.node_id}: instructions.operations is not a valid list.")
             return

        node.instructions.operations.append(op)
        node.arithmetic_operations_count += op.arithmetic_operations_count
        node.logical_operations_count += op.logical_operations_count
        logger.trace(f"Added op '{op.to_c()}' to node {node.node_id}")

        if op.arithmetic_operations_count > 0 or op.logical_operations_count > 0:
            logger.trace(f"Node {node.node_id} counts updated: Arith={node.arithmetic_operations_count}, Logic={node.logical_operations_count}")

    def _extract_step_from_operation(self, op: Operation, target_var: Variable) -> int:
        """Extracts the integer step value from a loop terminating operation

        Assumes the operation is an assignment like var = var + step or var = var - step

        Args:
            op: The Operation object.
            target_var: The variable being modified

        Returns:
            The integer step value (positive for increment, negative for decrement), defaults to 1
        """
        if not isinstance(op, ArithmeticOperation):
            return 1

        assigned_expr = op.expression
        if not isinstance(assigned_expr, ArithmeticExpression):
            return 1

        # Check for var = var + step or var = step + var
        if assigned_expr.operator == ArithmeticOperator.ADD:
            if (isinstance(assigned_expr.left, VariableExpression) and
                assigned_expr.left.variable == target_var and
                isinstance(assigned_expr.right, Constant) and isinstance(assigned_expr.right.value, int)):
                return cast(int, assigned_expr.right.value)
            if (isinstance(assigned_expr.right, VariableExpression) and
                assigned_expr.right.variable == target_var and
                isinstance(assigned_expr.left, Constant) and isinstance(assigned_expr.left.value, int)):
                 return cast(int, assigned_expr.left.value)

        # Check for var = var - step
        elif assigned_expr.operator == ArithmeticOperator.SUB:
             if (isinstance(assigned_expr.left, VariableExpression) and
                 assigned_expr.left.variable == target_var and
                 isinstance(assigned_expr.right, Constant) and isinstance(assigned_expr.right.value, int)):
                  return -cast(int, assigned_expr.right.value)

        logger.warning(f"Could not extract simple step value from operation '{op.to_c()}'. Defaulting to 1.")
        return 1